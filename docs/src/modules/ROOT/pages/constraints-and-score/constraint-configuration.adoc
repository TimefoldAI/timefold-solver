[#constraintConfiguration]
= Constraint configuration: adjust constraint weights dynamically
:doctype: book
:sectnums:
:icons: font

Deciding the correct xref:constraints-and-score/overview.adoc#scoreConstraintWeight[weight] and
xref:constraints-and-score/overview.adoc#scoreLevel[level] for each constraint is not easy.
It often involves negotiating with different stakeholders and their priorities.
Furthermore, quantifying the impact of soft constraints is often a new experience for business managers, so they'll need a number of iterations to get it right.

Don't get stuck between a rock and a hard place.
Provide a UI to adjust the constraint weights and visualize the resulting solution, so the business managers can tweak the constraint weights themselves:

image::constraints-and-score/constraint-configuration/parameterizeTheScoreWeights.png[align="center"]

[#createAConstraintConfiguration]
== Create a constraint configuration

First, create a new class to hold the constraint weights and other constraint parameters.
Annotate it with `@ConstraintConfiguration`:

[source,java,options="nowrap"]
----
@ConstraintConfiguration
public class VehicleRoutingConstraintConfiguration {
    ...
}
----

There will be exactly one instance of this class per planning solution.
The planning solution and the constraint configuration have a one-to-one relationship,
but they serve a different purpose, so they aren't merged into a single class.
A `@ConstraintConfiguration` class can extend a parent `@ConstraintConfiguration` class,
which can be useful in international use cases with many regional constraints.

Add the constraint configuration on the planning solution
and annotate that field or property with `@ConstraintConfigurationProvider`:

[source,java,options="nowrap"]
----
@PlanningSolution
public class VehicleRoutingSolution {

    @ConstraintConfigurationProvider
    private VehicleRoutingConstraintConfiguration constraintConfiguration;

    ...
}
----

The `@ConstraintConfigurationProvider` annotation automatically exposes the constraint configuration
as a xref:using-timefold-solver/modeling-planning-problems.adoc#problemFacts[problem fact],
there is no need to add a `@ProblemFactProperty` annotation.

The constraint configuration class holds the <<constraintWeight,constraint weights>>,
but it can also hold constraint parameters.


[#constraintWeight]
== Add a constraint weight for each constraint

In the constraint configuration class, add a `@ConstraintWeight` field or property for each constraint:

[source,java,options="nowrap"]
----
@ConstraintConfiguration(constraintPackage = "...vehiclerouting.score")
public class VehicleRoutingConstraintConfiguration {

    @ConstraintWeight("vehicleCapacity")
    private HardSoftScore vehicleCapacity = HardSoftScore.ofHard(1);
    @ConstraintWeight("serviceFinishedAfterMaxEndTime")
    private HardLongScore serviceFinishedAfterMaxEndTime = HardSoftScore.ofHard(1);

    @ConstraintWeight("minimizeTravelTime")
    private HardSoftScore minimizeTravelTime = HardSoftScore.ofSoft(1);

    ...
}
----

The type of the constraint weights must be the same score class as xref:using-timefold-solver/modeling-planning-problems.adoc#scoreOfASolution[the planning solution's score member].
For example in vehicle routing, `VehicleRoutingSolution.getScore()` and `VehicleRoutingConstraintConfiguration.getVehicleCapacity()`
both return a `HardSoftScore`.

A constraint weight cannot be null.
Give each constraint weight a default value, but expose them in a UI so the business users can tweak them.
The example above uses the `ofHard()` and `ofSoft()` methods to do that.
Normally, a constraint weight only uses one score level,
but it's possible to use multiple score levels (at a small performance cost).

Each constraint has a constraint package and a constraint name, together they form the constraint id.
These connect the constraint weight with the constraint implementation.
*For each constraint weight, there must be a constraint implementation with the same package and the same name.*

* The `@ConstraintConfiguration` annotation has a `constraintPackage` property that defaults to the package of the constraint configuration class.
Cases with xref:constraints-and-score/score-calculation.adoc[Constraint Streams API] normally don't need to specify it.

* The `@ConstraintWeight` annotation has a `value` which is the constraint name (for example "Speaker conflict").
It inherits the constraint package from the `@ConstraintConfiguration`,
but it can override that, for example `@ConstraintWeight(constraintPackage = "...region.france", ...)`
to use a different constraint package than some other weights.

So every constraint weight ends up with a constraint package and a constraint name.
Each constraint weight links with a constraint implementation,
for example in xref:constraints-and-score/score-calculation.adoc[Constraint Streams API]:

[source,java,options="nowrap"]
----
public class VehicleRoutingConstraintProvider implements ConstraintProvider {

    @Override
    public Constraint[] defineConstraints(ConstraintFactory factory) {
        return new Constraint[] {
                vehicleCapacity(factory),
                serviceFinishedAfterMaxEndTime(factory),
                minimizeTravelTime(factory)
        };
    }

    protected Constraint vehicleCapacity(ConstraintFactory factory) {
        return factory.forEach(Vehicle.class)
                ...
                .penalizeConfigurable(vehicle -> vehicle.getTotalDemand() - vehicle.getCapacity())
                .asConstraint("vehicleCapacity");
    }

    protected Constraint serviceFinishedAfterMaxEndTime(ConstraintFactory factory) {
        return factory.forEach(Visit.class)
                ...
                .penalizeConfigurable(Visit::getServiceFinishedDelayInMinutes)
                .asConstraint("serviceFinishedAfterMaxEndTime");
    }

    protected Constraint minimizeTravelTime(ConstraintFactory factory) {
        return factory.forEach(Vehicle.class)
                .penalizeConfigurable(Vehicle::getTotalDrivingTimeSeconds)
                .asConstraint("minimizeTravelTime");
    }
}
----

Each of the constraint weights defines the score level and score weight of their constraint.
The constraint implementation calls `rewardConfigurable()` or `penalizeConfigurable()` and the constraint weight is automatically applied.

If the constraint implementation provides a match weight, that *match weight is multiplied with the constraint weight*.
For example, in the following configuration,
each vehicle's total driving time is multiplied by 100 before it is added to the score.

[source,java,options="nowrap"]
----
    @ConstraintWeight("minimizeTravelTime")
    private HardSoftScore minimizeTravelTime = HardSoftScore.ofSoft(100);
----

[source,java,options="nowrap"]
----
Constraint minimizeTravelTime(ConstraintFactory factory) {
    return factory.forEach(Vehicle.class)
            .penalizeConfigurable(Vehicle::getTotalDrivingTimeSeconds)
            .asConstraint(minimizeTravelTime);
}
----