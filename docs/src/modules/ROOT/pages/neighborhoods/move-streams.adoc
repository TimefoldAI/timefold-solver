[#neighborhoodsMoveStreams]
= Producing custom moves
:doctype: book
:sectnums:
:icons: font

IMPORTANT: The Neighborhoods API is an active research project.
It intends to simplify the creation of custom moves, eventually replacing xref:optimization-algorithms/move-selector-reference.adoc[move selectors].
The component is under development and many key features are yet to be delivered.
While we believe that the basic building blocks of the API are already stable,
we reserve the right to change the API or remove any part of it.
Your feedback is highly appreciated and will be imperative in shaping the future of this component.

[#neighborhoodsMovesAndMoveStreams]
== Moves and Move Streams

While a move is an atomic change to a solution,
move streams are a way to generate a sequence of moves for the solver to choose from,
based on the current state of the working solution.
Moves send the solver from one solution to a neighboring solution,
and move streams define which moves will be available.

For users familiar with the xref:constraints-and-score/score-calculation.adoc#constraintStreams[Constraint Streams API],
many of the concepts of move streams will feel familiar.
We retain the declarative nature of the API with its underlying incremental evaluation and resulting excellent performance characteristics,
while bringing just-in-time move generation to the table as well.

Users familiar with xref:optimization-algorithms/move-selector-reference.adoc[move selectors] will find that move streams provide a more flexible and powerful way to define custom moves.
Many concepts of move selectors, such as filtering and selection strategies,
are naturally integrated into the new fluent API,
while other concepts (such as caching) are handled automatically by the framework.

[#neighborhoodsKeyConcepts]
== Key concepts

Move Streams consist of three key parts:

Enumeration::
This is the part that is the most similar to Constraint Streams.
It uses many of the same building blocks, and the same underlying execution engine,
to define and efficiently cache a set of values to generate moves from.
The product of this part is an in-memory dataset of potential move components;
for example, you would create a dataset of entities which your moves may want to change,
based on some specific criteria.
Sampling::
This part defines how to pick from the in-memory datasets generated by the enumeration part.
Typically, this involves picking a random combination of values from these datasets.
Unlike the enumeration part, which keeps its state in memory at all times,
sampling happens just-in-time when the solver requests a new move.
This avoids the creation of expensive and potentially huge cross-products.
For example, if you've enumerated all entities and all possible values they can take,
the sampling part would randomly select one entity and one value to create a move.
Move generation::
Takes the picked combination of enumerated values and creates a move out of them.
This move is then returned to the solver for execution.
For example, if we've picked an entity and value,
we want to generate a change move to assign the value to that entity's variable.

All three of these parts are defined together
in an implementation of the `ai.timefold.solver.core.preview.api.neighborhood.MoveDefinition` interface.
Each such move definition is expected to describe a single type of move -
for example, a move which tries different timeslot assignments in a school lesson.

Such a simple move definition could look like so:

[source,java]
----
public class TimeslotChangeMoveDefinition
        implements MoveDefinition<Timetable> {

    private PlanningVariableMetaModel<Timetable, Lesson, Timeslot> timeslotVariable;

    public TimeslotChangeMoveDefinition(PlanningVariableMetaModel<Timetable, Lesson, Timeslot> timeslotVariable) {
        this.timeslotVariable = Objects.requireNonNull(timeslotVariable);
    }

    @Override
    public MoveStream<Timetable> build(MoveStreamFactory<Timetable> factory) {
        var lessonEnumeration = factory.forEach(Lesson.class, false); // False means no null values.
        var timeslotEnumeration = factory.forEach(Timeslot.class, false);
        return factory.pick(lessonEnumeration)
                .pick(timeslotEnumeration,
                        filtering((solutionView, lesson, newTimeslot) -> lesson.timeslot != newTimeslot)) // Avoid no-op.
                .asMove((solutionView, lesson, newTimeslot) -> Moves.change(timeslotVariable, lesson, newTimeslot));
    }

}
----

We will explore each of these concepts in more detail below.


[#neighborhoodsEnumeration]
== Dataset Enumeration

The goal of dataset enumeration is to produce in-memory collections of values for the sampling phase to choose from.
This in-memory collection is kept up-to-date incrementally as the working solution changes,
using the same underlying engine as Constraint Streams.
This is not the only similarity to Constraint Streams though;
in fact the API for enumeration intends to resemble the Constraint Streams API as closely as possible,
but makes some carefully considered departures from it as well.

The entry point for enumeration is the `MoveStreamFactory.forEach` method,
which operates much like the xref:constraints-and-score/score-calculation.adoc#constraintStreamsForEach[`forEach()` method of Constraint Streams].
It was made smart enough to understand aspects of move generation such as pinning;
by default, `forEach` will exclude pinned items, as generating moves for pinned items is typically undesirable.
Additionally, it allows to specify whether it should include `null` in the resulting dataset or not;
this is useful when generating moves for nullable planning variables.

From there, many of the same building blocks are available,
such as xref:constraints-and-score/score-calculation.adoc#constraintStreamsFilter[`filter()`],
xref:constraints-and-score/score-calculation.adoc#constraintStreamsJoin[`join()`],
xref:constraints-and-score/score-calculation.adoc#constraintStreamsConditionalPropagation[`ifExists()`]
and others.
However, some building blocks from Constraint Streams are not available here,
and will only become available if we find a good justification to include them.
We also currently only support uni- and bi-streams,
as higher arity streams are likely unnecessary for move generation.

NOTE: As enumerated datasets are kept in memory at all times,
be cautious when enumerating large datasets and apply filtering as early as possible.
Take special care to avoid large cross-products.
This consideration is part of the rationale behind not including tri- and quad-streams;
the mere existence of these suggests memory-intensive cross-products.

All performance and functionality characteristics of Constraint Streams still apply here,
as the same underlying engine is used to execute these streams.
However, the signature of some of these methods may be slightly different to better suit the purpose of move generation. Consider a simple `filter` in Constraint Streams:

[source,java]
----
// Only return lessons that are not scheduled on Monday morning.
var lessonStream = factory.forEach(Lesson.class)
        .filter(lesson -> lesson.timeslot != MONDAY_MORNING)
        ...
----

Notice that the `filter` predicate only has access to the `lesson` instance.
In dataset enumeration, the predicate also has access to a `SolutionView` instance,
which provides read-only access to the working solution to be able to make some complex decisions:

[source,java]
----
// Only return lessons that can be scheduled on Monday morning.
var lessonEnumeration = factory.forEach(Lesson.class, false)
        .filter((solutionView, lesson) -> solutionView.isValueInRange(timeslotVariable, lesson, MONDAY_MORNING))
        ...
----

In this case, we have used the `SolutionView.isValueInRange` method to check whether
the `MONDAY_MORNING` timeslot is a valid value for the `timeslotVariable` of the given `lesson`.
If that's not the case, we filter out this lesson from the enumeration
and therefore will not generate moves which use this lesson.

The same pattern applies to other building blocks as well, such as `join` and `ifExists`;
essentially, the `solutionView` argument was added to every predicate or function where it could be useful.


[#neighborhoodsSampling]
== Sampling the datasets

Once we have defined our enumerations, we need to define how to pick from them to create moves.
This is done using the `MoveStreamFactory.pick` method,
which takes an enumeration as argument and returns another builder to continue picking from more enumerations.

The difference between enumeration and sampling is that enumeration keeps its state in memory at all times,
while sampling happens just-in-time when the solver requests a new move.
This is important to avoid creating cross-products of enumerated datasets,
which would make move generation practically impossible within the constraints of today's hardware.

Picking happens randomly; that is, each time the solver requests a new move,
the sampling phase randomly selects one item from each enumeration.
This random selection is uniform across the entire dataset; that is, each item has an equal chance of being selected.
However, we can apply filtering to the sampling phase to avoid certain combinations of items,
as we've already seen in the simple example above:

[source,java]
----
public class TimeslotChangeMoveDefinition implements MoveDefinition<Timetable> {

    ...

    @Override
    public MoveStream<Timetable> build(MoveStreamFactory<Timetable> factory) {
        ...
        return factory.pick(lessonEnumeration)
                .pick(timeslotEnumeration,
                        filtering((solutionView, lesson, newTimeslot) -> lesson.timeslot != newTimeslot))
                ...
    }

}
----

In this case, we have applied a filter to the picking of `timeslotEnumeration`
to avoid picking the same timeslot that the lesson is already assigned to.
This avoids generating a move which would not change the solution at all.
It is the responsibility of the move definition to avoid generating no-op moves;
if the solver receives a no-op move, it will execute it anyway, wasting time and resources.

The end result of the sampling phase is a random combination of items from the enumerations;
in the example above, this would be a random `Lesson` and a random `Timeslot`.
This pair of picked items is then passed to the move generation phase,
and the process of sampling is repeated each time the solver requests a new move to be generated.

The sampling phase currently only supports applying filtering and a limited selection of joiners,
found in the `ai.timefold.solver.core.preview.api.neighborhood.joiner.NeighborhoodsJoiners` class.
More advanced selection strategies,
such as xref:enterprise-edition/enterprise-edition.adoc#nearbySelection[nearby selection],
are likely to materialize here in the future as well.

[#neighborhoodsMoveGeneration]
== Move Generation

Having already enumerated datasets and defined how to sample from them,
the final step is to generate a move from the picked items.
This is done using the `asMove` method on the builder,
which takes a function that creates a move from the picked items.
This function also has access to the `SolutionView` instance,
in case the move generation logic needs to read some additional data from the working solution.

In our simple example, move generation looks like this:

[source,java]
----
public class TimeslotChangeMoveDefinition implements MoveDefinition<Timetable> {

    ...

    @Override
    public MoveStream<Timetable> build(MoveStreamFactory<Timetable> factory) {
        ...
        return factory.pick(...)
                .pick(...)
                .asMove((solutionView, lesson, newTimeslot) -> Moves.change(timeslotVariable, lesson, newTimeslot));
    }

}
----

In this case, we create a built-in change move using the `Moves.change` factory method,
which takes the planning variable meta-model, the entity to change,
and the new value to assign to the variable.
This move is then returned to the solver for execution.

The move generation function can create any type of move - see a xref:neighborhoods/move.adoc[section on moves] for more details. However, we expect that most move definitions will eventually be able to use the built-in moves,
which will be expanded over time to cover more use cases.