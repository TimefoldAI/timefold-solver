package ai.timefold.solver.core.impl.exhaustivesearch.decider;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import ai.timefold.solver.core.api.score.Score;
import ai.timefold.solver.core.impl.domain.variable.ListVariableStateSupply;
import ai.timefold.solver.core.impl.domain.variable.descriptor.ListVariableDescriptor;
import ai.timefold.solver.core.impl.exhaustivesearch.node.ExhaustiveSearchLayer;
import ai.timefold.solver.core.impl.exhaustivesearch.node.ExhaustiveSearchNode;
import ai.timefold.solver.core.impl.exhaustivesearch.node.bounder.ScoreBounder;
import ai.timefold.solver.core.impl.exhaustivesearch.scope.ExhaustiveSearchPhaseScope;
import ai.timefold.solver.core.impl.exhaustivesearch.scope.ExhaustiveSearchStepScope;
import ai.timefold.solver.core.impl.heuristic.selector.entity.EntitySelector;
import ai.timefold.solver.core.impl.heuristic.selector.entity.mimic.ManualEntityMimicRecorder;
import ai.timefold.solver.core.impl.neighborhood.MoveRepository;
import ai.timefold.solver.core.impl.score.director.ValueRangeManager;
import ai.timefold.solver.core.impl.solver.recaller.BestSolutionRecaller;
import ai.timefold.solver.core.impl.solver.termination.PhaseTermination;
import ai.timefold.solver.core.impl.util.MutableInt;
import ai.timefold.solver.core.preview.api.move.Move;
import ai.timefold.solver.core.preview.api.move.builtin.CompositeMove;
import ai.timefold.solver.core.preview.api.move.builtin.Moves;

public final class ListVariableExhaustiveSearchDecider<Solution_> extends ExhaustiveSearchDecider<Solution_> {

    private ValueRangeManager<Solution_> valueRangeManager;
    private ListVariableDescriptor<Solution_> listVariableDescriptor;
    private ListVariableStateSupply<Solution_, ?, ?> listVariableState;

    private ExhaustiveSearchLayer currentSearchLayer;

    public ListVariableExhaustiveSearchDecider(String logIndentation, BestSolutionRecaller<Solution_> bestSolutionRecaller,
            PhaseTermination<Solution_> termination, EntitySelector<Solution_> sourceEntitySelector,
            ManualEntityMimicRecorder<Solution_> manualEntityMimicRecorder, MoveRepository<Solution_> moveRepository,
            boolean scoreBounderEnabled, ScoreBounder<?> scoreBounder) {
        super(logIndentation, bestSolutionRecaller, termination, sourceEntitySelector, manualEntityMimicRecorder,
                moveRepository, scoreBounderEnabled, scoreBounder);
    }

    // ************************************************************************
    // Worker methods
    // ************************************************************************

    /**
     * The method updates the exploration of the solution's space when using a list variable.
     * The logic will start adding all possible search nodes
     * that belong to the initial layer being generated by {@link #initStartNode}.
     * This strategy ensures the breadth-first method works as all values assigned to the same layer will have the equal depth.
     * For example, considering the values {@code [v0, v1, v2]} and the entity {@code e0} from layer {@code 0},
     * the resulting nodes are:
     * <p>
     * {@code (layer 0, e0,  [v0]), (layer 0, e0, [v1]) (layer 0, e0, [v2]), (layer 0, e0, [v0, v1]), 
     * (layer 0, e0, [v0, v2]), (layer 0, e0, [v1, v0]), (layer 0, e0, [v1, v2]), (layer 0, e0, [v2, v0]), 
     * (layer 0, e0, [v2, v1]), (layer 0, e0, [v0, v1, v2]), (layer 0, e0, [v0, v2, 1]), (layer 0, e0, [v1, v0, v2]), 
     * (layer 0, e0, [v1, v2, v0]), (layer 0, e0, [v2, v0, v1]), (layer 0, e0, [v2, v1, v0])}.
     * <p>
     * After selecting a search node,
     * all possible moves for the subsequent layers are generated.
     * This step is essential to prevent the reevaluation of already visited solutions.
     * It's important to note that both the current and previous layers have already evaluated all possible permutations,
     * as described previously.
     */
    @Override
    public void expandNode(ExhaustiveSearchStepScope<Solution_> stepScope) {
        var phaseScope = stepScope.getPhaseScope();
        var expandingNode = stepScope.getExpandingNode();
        // We need to make sure that all layers following the current one are evaluated
        var moveIndex = new MutableInt(0);
        // There are no more values available
        if (listVariableState.getUnassignedCount() == 0) {
            moveIndex.increment();
            doMove(stepScope, expandingNode, true, true);
            phaseScope.addMoveEvaluationCount(expandingNode.getMove(), 1);
        } else {
            for (var i = currentSearchLayer.getDepth() + 1; i < phaseScope.getLayerList().size(); i++) {
                var layer = phaseScope.getLayerList().get(i);
                if (layer.isLastLayer()) {
                    break;
                }
                manualEntityMimicRecorder.setRecordedEntity(layer.getEntity());
                // Expand only the current selected node for basic variables
                var sameLayer = expandingNode.getLayer() == layer;
                var moveLayer = sameLayer ? layer : nextLayer(phaseScope, layer);
                expandNode(stepScope, expandingNode, moveLayer, moveIndex);
                stepScope.setSelectedMoveCount(moveIndex.longValue());
            }
        }
    }

    @Override
    public boolean isSolutionComplete(ExhaustiveSearchNode expandingNode) {
        // One value to be assigned and one move to be done
        return listVariableState.getUnassignedCount() <= 1;
    }

    @Override
    protected void fillLayerList(ExhaustiveSearchPhaseScope<Solution_> phaseScope) {
        var stepScope = new ExhaustiveSearchStepScope<>(phaseScope);
        sourceEntitySelector.stepStarted(stepScope);
        var entitySize = sourceEntitySelector.getSize();
        if (entitySize > Integer.MAX_VALUE) {
            throw new IllegalStateException(
                    "The entitySelector (%s) has an entitySize (%d) which is higher than Integer.MAX_VALUE."
                            .formatted(sourceEntitySelector, entitySize));
        }
        var layerList = new ArrayList<ExhaustiveSearchLayer>((int) entitySize);
        var depth = 0;
        for (var entity : sourceEntitySelector) {
            var layer = new ExhaustiveSearchLayer(depth++, entity);
            layerList.add(layer);
        }
        var lastLayer = new ExhaustiveSearchLayer(depth, null);
        layerList.add(lastLayer);
        sourceEntitySelector.stepEnded(stepScope);
        phaseScope.setLayerList(layerList);
    }

    @Override
    protected <Score_ extends Score<Score_>> void initStartNode(ExhaustiveSearchPhaseScope<Solution_> phaseScope,
            ExhaustiveSearchLayer layer) {
        currentSearchLayer = layer == null ? phaseScope.getLayerList().get(0) : layer;
        var startNode = new ExhaustiveSearchNode(currentSearchLayer, null);

        if (scoreBounderEnabled) {
            var scoreDirector = phaseScope.<Score_> getScoreDirector();
            var score = scoreDirector.calculateScore();
            startNode.setScore(score);
            ScoreBounder<Score_> scoreBounder = getScoreBounder();
            phaseScope.setBestPessimisticBound(currentSearchLayer.isLastLayer() ? score
                    : scoreBounder.calculatePessimisticBound(scoreDirector, score));
            startNode.setOptimisticBound(currentSearchLayer.isLastLayer() ? score
                    : scoreBounder.calculateOptimisticBound(scoreDirector, score));
        }

        phaseScope.getLastCompletedStepScope().setExpandingNode(startNode);

        if (!currentSearchLayer.isLastLayer()) {
            // The proposed strategy generates all possible expandable nodes for the current layer.
            // This approach allows for the assignment of multiple values in the current layer,
            // enabling the exploration of all possible permutations from the subsequent layers.
            generateAllExpandableNodesForLayer(phaseScope, currentSearchLayer, startNode);
        }
    }

    /**
     * An expandable node is a search point where the solver can branch out and explore new solutions.
     * This method enumerates the possible combinations for each size incrementally.
     * When considering the values {@code [v0, v1, v2]}, the resulting nodes are:
     * <p>
     * Size of {@code 1}: {@code [v0], [v1], [v2]}
     * <p>
     * Size of {@code 2}: {@code [v0, v1], [v0, v2], [v1, v0], [v1, v2], [v2, v0], [v2, v1]}
     * <p>
     * Size of {@code 3}: {@code [v0, v1, v2], [v0, v2, 1], [v1, v0, v2], [v1, v2, v0], [v2, v0, v1], [v2, v1, v0]}
     * 
     * @param phaseScope the phase scope
     * @param layer the target layer
     * @param parentNode the parent node
     */
    private void generateAllExpandableNodesForLayer(ExhaustiveSearchPhaseScope<Solution_> phaseScope,
            ExhaustiveSearchLayer layer, ExhaustiveSearchNode parentNode) {
        var valueRange =
                valueRangeManager.getFromEntity(listVariableDescriptor.getValueRangeDescriptor(), layer.getEntity());
        var size = (int) valueRange.getSize();
        var allValueList = new ArrayList<>(size);
        valueRange.createOriginalIterator().forEachRemaining(v -> {
            if (v != null) {
                allValueList.add(v);
            }
        });
        var listVariableMetaModel = listVariableDescriptor.getVariableMetaModel();
        for (var combinationSize = 1; combinationSize <= size; combinationSize++) {
            var allCombinations = generateCombinations(layer, allValueList, combinationSize);
            for (var combination : allCombinations) {
                var assignMoveList = new ArrayList<Move<Solution_>>(combinationSize);
                var unassignMoveList = new ArrayList<Move<Solution_>>(combinationSize);
                var idx = 0;
                for (var value : combination.values()) {
                    assignMoveList.add(Moves.assign(listVariableMetaModel, value, layer.getEntity(), idx));
                    // Late moves must be undone first
                    unassignMoveList.add(0, Moves.unassign(listVariableMetaModel, layer.getEntity(), idx));
                    idx++;
                }
                var node = new ExhaustiveSearchNode(currentSearchLayer, parentNode);
                node.setMove(CompositeMove.buildMove(assignMoveList.toArray(Move[]::new)));
                node.setUndoMove(CompositeMove.buildMove(unassignMoveList.toArray(Move[]::new)));
                phaseScope.addExpandableNode(node);
            }
        }

    }

    /**
     * Generate all possible combinations of {@code n} values of size {@code p},
     * including repeated inverse elements, such as {@code [v1, v2}] and {@code [v2, v1}].
     *
     * @param layer the target layer
     * @param allValueList all available values and their index
     * @param size the size of the combination
     * 
     * @return a list of all combinations for the given values list with the specified size.
     * 
     * @param <T> the type of the value
     */
    @SuppressWarnings("unchecked")
    private <T> List<Combination<T>> generateCombinations(ExhaustiveSearchLayer layer, List<T> allValueList, int size) {
        var allCombinations = new ArrayList<Combination<T>>();
        for (var i = 0; i < allValueList.size(); i++) {
            var value = allValueList.get(i);
            var currentCombination = new Combination<T>(new LinkedHashSet<>(allValueList.size()));
            var currentValuesList = listVariableDescriptor.getValue(layer.getEntity());
            // We will include the existing values in case pinning is required
            if (!currentValuesList.isEmpty()) {
                for (var v : currentValuesList) {
                    currentCombination.values().add((T) v);
                }
            }
            // Generate combinations with the value at the position i
            currentCombination.add(value);
            generateCombinations(allCombinations, allValueList, currentCombination,
                    listVariableDescriptor.getFirstUnpinnedIndex(layer.getEntity()), size);
        }
        return allCombinations;
    }

    private <T> void generateCombinations(List<Combination<T>> result, List<T> allValueList, Combination<T> searchNode,
            int startIndex, int size) {
        for (var i = startIndex; i < allValueList.size(); i++) {
            var value = allValueList.get(i);
            if (searchNode.values().contains(value)) {
                // Already assigned
                continue;
            }
            if (searchNode.getSize() == size) {
                result.add(searchNode);
                return;
            } else if (searchNode.getSize() + 1 == size) {
                // Add a result
                var combination = searchNode.copy();
                combination.add(value);
                result.add(combination);
            } else {
                // Expand the search
                var expandSearchNode = searchNode.copy();
                expandSearchNode.add(value);
                generateCombinations(result, allValueList, expandSearchNode, 0, size);
            }
        }
    }

    private ExhaustiveSearchLayer nextLayer(ExhaustiveSearchPhaseScope<Solution_> phaseScope, ExhaustiveSearchLayer layer) {
        return phaseScope.getLayerList().get(layer.getDepth() + 1);
    }

    @Override
    public <Score_ extends Score<Score_>> void restoreWorkingSolution(ExhaustiveSearchStepScope<Solution_> stepScope,
            boolean assertWorkingSolutionScoreFromScratch, boolean assertExpectedWorkingSolutionScore) {
        var phaseScope = stepScope.getPhaseScope();
        //First, undo all previous changes
        var undoNode = phaseScope.getLastCompletedStepScope().getExpandingNode();
        var unassignMoveList = new ArrayList<Move<Solution_>>();
        while (undoNode.getUndoMove() != null) {
            unassignMoveList.add(0, undoNode.getUndoMove());
            undoNode = undoNode.getParent();
        }
        // Next, rebuild the solution starting from the current search element
        var assignNode = stepScope.getExpandingNode();
        var assignMoveList = new ArrayList<Move<Solution_>>();
        while (assignNode.getMove() != null) {
            assignMoveList.add(assignNode.getMove());
            assignNode = assignNode.getParent();
        }
        Collections.reverse(assignMoveList);
        var allMoves = new ArrayList<Move<Solution_>>(unassignMoveList.size() + assignMoveList.size());
        allMoves.addAll(unassignMoveList);
        allMoves.addAll(assignMoveList);
        if (allMoves.isEmpty()) {
            // No moves to restore, so the working solution is already correct
            return;
        }
        var compositeMove = Moves.compose(allMoves);
        phaseScope.getScoreDirector().executeMove(compositeMove);
        var score = phaseScope.<Score_> calculateScore();
        stepScope.getExpandingNode().setScore(score);
        phaseScope.getSolutionDescriptor().setScore(phaseScope.getWorkingSolution(), score.raw());
    }

    private record Combination<T>(Set<T> values) {

        public void add(T value) {
            values.add(value);
        }

        public int getSize() {
            return values.size();
        }

        public Combination<T> copy() {
            var newValues = new LinkedHashSet<>(values);
            return new Combination<>(newValues);
        }
    }

    // ************************************************************************
    // Lifecycle methods
    // ************************************************************************

    @Override
    public void phaseStarted(ExhaustiveSearchPhaseScope<Solution_> phaseScope) {
        this.listVariableDescriptor = phaseScope.getSolutionDescriptor().getListVariableDescriptor();
        this.listVariableState =
                phaseScope.getSolverScope().getScoreDirector().getListVariableStateSupply(listVariableDescriptor);
        this.valueRangeManager = phaseScope.getSolverScope().getScoreDirector().getValueRangeManager();
        super.phaseStarted(phaseScope);
    }

    @Override
    public void phaseEnded(ExhaustiveSearchPhaseScope<Solution_> phaseScope) {
        super.phaseEnded(phaseScope);
        this.listVariableDescriptor = null;
        this.listVariableState = null;
        this.valueRangeManager = null;
    }

    @Override
    public void stepEnded(ExhaustiveSearchStepScope<Solution_> stepScope) {
        super.stepEnded(stepScope);
        // When there are no more nodes for the current layer, we need to add the next one and move forward
        var phaseScope = stepScope.getPhaseScope();
        if (phaseScope.getExpandableNodeQueue().isEmpty() && !currentSearchLayer.isLastLayer()) {
            currentSearchLayer = phaseScope.getLayerList().get(currentSearchLayer.getDepth() + 1);
            initStartNode(phaseScope, currentSearchLayer);
        }
    }
}
