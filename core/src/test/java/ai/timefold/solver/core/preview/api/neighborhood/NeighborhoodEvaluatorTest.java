package ai.timefold.solver.core.preview.api.neighborhood;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.SoftAssertions.assertSoftly;

import ai.timefold.solver.core.preview.api.move.builtin.ChangeMove;
import ai.timefold.solver.core.preview.api.move.builtin.ChangeMoveProvider;
import ai.timefold.solver.core.testdomain.TestdataEntity;
import ai.timefold.solver.core.testdomain.TestdataSolution;
import ai.timefold.solver.core.testdomain.TestdataValue;

import org.junit.jupiter.api.Test;

// Much of the test coverage for NeighborhoodEvaluator is in tests for the specific MoveProviders.
// There is no better coverage than real-world use cases. (Eating our own dog food.)
class NeighborhoodEvaluatorTest {

    @Test
    void temporaryMoveExecutionDoesNotAffectMoveIterator() {
        var solutionMetaModel = TestdataSolution.buildMetaModel();
        var variableMetaModel = solutionMetaModel.genuineEntity(TestdataEntity.class)
                .basicVariable();

        var solution = TestdataSolution.generateSolution(2, 2);
        var firstEntity = solution.getEntityList().get(0);
        firstEntity.setValue(null);
        var secondEntity = solution.getEntityList().get(1);
        secondEntity.setValue(null);
        var firstValue = solution.getValueList().get(0);
        var secondValue = solution.getValueList().get(1);

        var evaluatedNeighborhood = NeighborhoodEvaluator.build(new ChangeMoveProvider<>(variableMetaModel), solutionMetaModel)
                .using(solution);
        var moveIterator = evaluatedNeighborhood
                .getMovesAsIterator(move -> (ChangeMove<TestdataSolution, TestdataEntity, TestdataValue>) move);

        assertThat(moveIterator).hasNext();

        // This test depends on the implicit order of moves generated by ChangeMoveProvider.
        // If that order changes, this test will need to be updated.
        var firstMove = moveIterator.next();
        evaluatedNeighborhood.getMoveRunContext()
                .executeTemporarily(firstMove, solutionView -> assertThat(firstEntity.getValue())
                        .isEqualTo(firstValue));
        assertThat(firstEntity.getValue()).isNull();
        ;

        // There should be 3 more moves in the iterator, each different from the first.
        // - Set the firstEntity value to secondValue,
        // - set the secondEntity value to firstValue,
        // - set the secondEntity value to secondValue.
        var secondMove = moveIterator.next();
        assertSoftly(softly -> {
            softly.assertThat(secondMove.getPlanningEntities())
                    .containsExactly(firstEntity);
            softly.assertThat(secondMove.getPlanningValues())
                    .containsExactly(secondValue);
        });

        var thirdMove = moveIterator.next();
        assertSoftly(softly -> {
            softly.assertThat(thirdMove.getPlanningEntities())
                    .containsExactly(secondEntity);
            softly.assertThat(thirdMove.getPlanningValues())
                    .containsExactly(firstValue);
        });

        var fourthMove = moveIterator.next();
        assertSoftly(softly -> {
            softly.assertThat(fourthMove.getPlanningEntities())
                    .containsExactly(secondEntity);
            softly.assertThat(fourthMove.getPlanningValues())
                    .containsExactly(secondValue);
        });

    }

    @Test
    void newIteratorAfterMoveExecution() {
        var solutionMetaModel = TestdataSolution.buildMetaModel();
        var variableMetaModel = solutionMetaModel.genuineEntity(TestdataEntity.class)
                .basicVariable();

        var solution = TestdataSolution.generateSolution(2, 2);
        var firstEntity = solution.getEntityList().get(0);
        firstEntity.setValue(null);
        var secondEntity = solution.getEntityList().get(1);
        secondEntity.setValue(null);
        var firstValue = solution.getValueList().get(0);
        var secondValue = solution.getValueList().get(1);

        var evaluatedNeighborhood = NeighborhoodEvaluator.build(new ChangeMoveProvider<>(variableMetaModel), solutionMetaModel)
                .using(solution);
        var moveList =
                evaluatedNeighborhood
                        .getMovesAsList(move -> (ChangeMove<TestdataSolution, TestdataEntity, TestdataValue>) move);
        assertThat(moveList).hasSize(4);

        // This test depends on the implicit order of moves generated by ChangeMoveProvider.
        // If that order changes, this test will need to be updated.
        var firstMove = moveList.get(0);
        evaluatedNeighborhood.getMoveRunContext()
                .execute(firstMove);
        assertThat(firstEntity.getValue()).isEqualTo(firstValue);

        // New move list, now that the move has been executed, changing firstEntity's value to firstValue.
        // There should be 3 moves in the new iterator.
        // - Set the firstEntity value to secondValue,
        // - set the secondEntity value to firstValue,
        // - set the secondEntity value to secondValue.
        moveList = evaluatedNeighborhood
                .getMovesAsList(move -> (ChangeMove<TestdataSolution, TestdataEntity, TestdataValue>) move);
        assertThat(moveList).hasSize(3);

        var secondMove = moveList.get(0);
        assertSoftly(softly -> {
            softly.assertThat(secondMove.getPlanningEntities())
                    .containsExactly(firstEntity);
            softly.assertThat(secondMove.getPlanningValues())
                    .containsExactly(secondValue);
        });

        var thirdMove = moveList.get(1);
        assertSoftly(softly -> {
            softly.assertThat(thirdMove.getPlanningEntities())
                    .containsExactly(secondEntity);
            softly.assertThat(thirdMove.getPlanningValues())
                    .containsExactly(firstValue);
        });

        var fourthMove = moveList.get(2);
        assertSoftly(softly -> {
            softly.assertThat(fourthMove.getPlanningEntities())
                    .containsExactly(secondEntity);
            softly.assertThat(fourthMove.getPlanningValues())
                    .containsExactly(secondValue);
        });

    }

}
